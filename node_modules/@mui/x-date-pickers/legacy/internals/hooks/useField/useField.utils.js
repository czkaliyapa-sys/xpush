import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
export var getDateSectionConfigFromFormatToken = function getDateSectionConfigFromFormatToken(utils, formatToken) {
  var config = utils.formatTokenMap[formatToken];
  if (config == null) {
    throw new Error(["MUI: The token \"".concat(formatToken, "\" is not supported by the Date and Time Pickers."), 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\n'));
  }
  if (typeof config === 'string') {
    return {
      dateSectionName: config,
      contentType: config === 'meridiem' ? 'letter' : 'digit'
    };
  }
  return {
    dateSectionName: config.sectionName,
    contentType: config.contentType
  };
};
var getDeltaFromKeyCode = function getDeltaFromKeyCode(keyCode) {
  switch (keyCode) {
    case 'ArrowUp':
      return 1;
    case 'ArrowDown':
      return -1;
    case 'PageUp':
      return 5;
    case 'PageDown':
      return -5;
    default:
      return 0;
  }
};
export var getDaysInWeekStr = function getDaysInWeekStr(utils, format) {
  var elements = [];
  var now = utils.date();
  var startDate = utils.startOfWeek(now);
  var endDate = utils.endOfWeek(now);
  var current = startDate;
  while (utils.isBefore(current, endDate)) {
    elements.push(current);
    current = utils.addDays(current, 1);
  }
  return elements.map(function (weekDay) {
    return utils.formatByString(weekDay, format);
  });
};
export var adjustDateSectionValue = function adjustDateSectionValue(utils, date, dateSectionName, keyCode) {
  var delta = getDeltaFromKeyCode(keyCode);
  var isStart = keyCode === 'Home';
  var isEnd = keyCode === 'End';
  switch (dateSectionName) {
    case 'day':
      {
        if (isStart) {
          return utils.startOfMonth(date);
        }
        if (isEnd) {
          return utils.endOfMonth(date);
        }
        return utils.addDays(date, delta);
      }
    case 'weekDay':
      {
        if (isStart) {
          return utils.startOfWeek(date);
        }
        if (isEnd) {
          return utils.endOfWeek(date);
        }
        return utils.addDays(date, delta);
      }
    case 'month':
      {
        if (isStart) {
          return utils.startOfYear(date);
        }
        if (isEnd) {
          return utils.endOfYear(date);
        }
        return utils.addMonths(date, delta);
      }
    case 'year':
      {
        return utils.addYears(date, delta);
      }
    case 'meridiem':
      {
        return utils.addHours(date, (delta > 0 ? 1 : -1) * 12);
      }
    case 'hours':
      {
        if (isStart) {
          return utils.startOfDay(date);
        }
        if (isEnd) {
          return utils.endOfDay(date);
        }
        return utils.addHours(date, delta);
      }
    case 'minutes':
      {
        if (isStart) {
          return utils.setMinutes(date, 0);
        }
        if (isEnd) {
          return utils.setMinutes(date, 59);
        }
        return utils.addMinutes(date, delta);
      }
    case 'seconds':
      {
        if (isStart) {
          return utils.setSeconds(date, 0);
        }
        if (isEnd) {
          return utils.setSeconds(date, 59);
        }
        return utils.addSeconds(date, delta);
      }
    default:
      {
        return date;
      }
  }
};
export var adjustInvalidDateSectionValue = function adjustInvalidDateSectionValue(utils, section, keyCode) {
  var today = utils.date();
  var delta = getDeltaFromKeyCode(keyCode);
  var isStart = keyCode === 'Home';
  var isEnd = keyCode === 'End';
  var shouldSetAbsolute = section.value === '' || isStart || isEnd;
  switch (section.dateSectionName) {
    case 'year':
      {
        if (section.value === '') {
          return utils.formatByString(today, section.formatValue);
        }
        return utils.formatByString(utils.setYear(today, Number(section.value) + delta), section.formatValue);
      }
    case 'month':
      {
        var newDate;
        if (shouldSetAbsolute) {
          if (delta > 0 || isEnd) {
            newDate = utils.startOfYear(today);
          } else {
            newDate = utils.endOfYear(today);
          }
        } else {
          newDate = utils.addMonths(utils.parse(section.value, section.formatValue), delta);
        }
        return utils.formatByString(newDate, section.formatValue);
      }
    case 'day':
      {
        var _newDate;
        if (shouldSetAbsolute) {
          if (delta > 0 || isEnd) {
            _newDate = utils.startOfMonth(today);
          } else {
            _newDate = utils.endOfMonth(today);
          }
        } else {
          _newDate = utils.addDays(utils.parse(section.value, section.formatValue), delta);
          if (!utils.isSameMonth(_newDate, today)) {
            if (delta > 0) {
              _newDate = utils.startOfMonth(today);
            } else {
              _newDate = utils.endOfMonth(today);
            }
          }
        }
        return utils.formatByString(_newDate, section.formatValue);
      }
    case 'weekDay':
      {
        var _newDate2;
        if (shouldSetAbsolute) {
          if (delta > 0 || isEnd) {
            _newDate2 = utils.startOfWeek(today);
          } else {
            _newDate2 = utils.endOfWeek(today);
          }
          return utils.formatByString(_newDate2, section.formatValue);
        }
        var formattedDaysInWeek = getDaysInWeekStr(utils, section.formatValue);
        var currentDayInWeek = formattedDaysInWeek.indexOf(section.value);
        var newDayInWeek = (currentDayInWeek + formattedDaysInWeek.length + delta) % formattedDaysInWeek.length;
        return formattedDaysInWeek[newDayInWeek];
      }
    case 'meridiem':
      {
        var am = utils.formatByString(utils.startOfDay(today), section.formatValue);
        var pm = utils.formatByString(utils.endOfDay(today), section.formatValue);
        if (section.value === '') {
          if (delta > 0 || isEnd) {
            return am;
          }
          return pm;
        }
        if (section.value === am) {
          return pm;
        }
        return am;
      }
    case 'hours':
      {
        var _newDate3;
        if (shouldSetAbsolute) {
          if (delta > 0 || isEnd) {
            _newDate3 = utils.startOfDay(today);
          } else {
            _newDate3 = utils.endOfDay(today);
          }
        } else {
          _newDate3 = utils.addHours(utils.setHours(today, Number(section.value)), delta);
        }
        return utils.formatByString(_newDate3, section.formatValue);
      }
    case 'minutes':
      {
        var _newDate4;
        if (section.value === '') {
          // TODO: Add startOfHour and endOfHours to adapters to avoid hard-coding those values
          var newNumericValue = delta > 0 || isEnd ? 0 : 59;
          _newDate4 = utils.setMinutes(today, newNumericValue);
        } else {
          _newDate4 = utils.addMinutes(utils.setMinutes(today, Number(section.value)), delta);
        }
        return utils.formatByString(_newDate4, section.formatValue);
      }
    case 'seconds':
      {
        var _newDate5;
        if (section.value === '') {
          // TODO: Add startOfMinute and endOfMinute to adapters to avoid hard-coding those values
          var _newNumericValue = delta > 0 || isEnd ? 0 : 59;
          _newDate5 = utils.setSeconds(today, _newNumericValue);
        } else {
          _newDate5 = utils.addSeconds(utils.setSeconds(today, Number(section.value)), delta);
        }
        return utils.formatByString(_newDate5, section.formatValue);
      }
    default:
      {
        throw new Error("Invalid date section name");
      }
  }
};
export var getSectionVisibleValue = function getSectionVisibleValue(section, willBeRenderedInInput) {
  var value = section.value || section.placeholder;

  // In the input, we add an empty character at the end of each section without trailing zeros.
  // This make sure that `onChange` will always be fired.
  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),
  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,
  // So the browser will not fire the input `onChange`.
  // Adding the ltr mark is not a problem because it's only for digit (which are always ltr)
  // The \u2068 and \u2069 are cleaned, but not the \u200e to notice that an update with same digit occurs
  if (willBeRenderedInInput && section.contentType === 'digit' && !section.hasTrailingZeroes && value.length === 1) {
    return "\u2068".concat(value, "\u200E\u2069");
  }
  if (willBeRenderedInInput) {
    return "\u2068".concat(value, "\u2069");
  }
  return value;
};
export var cleanString = function cleanString(dirtyString) {
  return dirtyString.replace(/\u2066|\u2067|\u2068|\u2069/g, '');
};
export var addPositionPropertiesToSections = function addPositionPropertiesToSections(sections) {
  var position = 0;
  var positionInInput = 1;
  var newSections = [];
  for (var i = 0; i < sections.length; i += 1) {
    var section = sections[i];
    var renderedValue = getSectionVisibleValue(section, true);
    var sectionStr = "".concat(section.startSeparator).concat(renderedValue).concat(section.endSeparator);
    var sectionLength = cleanString(sectionStr).length;
    var sectionLengthInInput = sectionStr.length;

    // The ...InInput values consider the unicode characters but do include them in their indexes
    var cleanedValue = cleanString(renderedValue);
    var startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;
    var endInInput = startInInput + cleanedValue.length;
    newSections.push(_extends({}, section, {
      start: position,
      end: position + sectionLength,
      startInInput: startInInput,
      endInInput: endInInput
    }));
    position += sectionLength;
    // Move position to the end of string associated to the current section
    positionInInput += sectionLengthInInput;
  }
  return newSections;
};
var getSectionPlaceholder = function getSectionPlaceholder(utils, localeText, sectionConfig, currentTokenValue) {
  switch (sectionConfig.dateSectionName) {
    case 'year':
      {
        return localeText.fieldYearPlaceholder({
          digitAmount: utils.formatByString(utils.date(), currentTokenValue).length
        });
      }
    case 'month':
      {
        return localeText.fieldMonthPlaceholder({
          contentType: sectionConfig.contentType
        });
      }
    case 'day':
      {
        return localeText.fieldDayPlaceholder();
      }
    case 'weekDay':
      {
        return localeText.fieldWeekDayPlaceholder({
          contentType: sectionConfig.contentType
        });
      }
    case 'hours':
      {
        return localeText.fieldHoursPlaceholder();
      }
    case 'minutes':
      {
        return localeText.fieldMinutesPlaceholder();
      }
    case 'seconds':
      {
        return localeText.fieldSecondsPlaceholder();
      }
    case 'meridiem':
      {
        return localeText.fieldMeridiemPlaceholder();
      }
    default:
      {
        return currentTokenValue;
      }
  }
};
export var changeSectionValueFormat = function changeSectionValueFormat(utils, valueStr, currentFormat, newFormat) {
  if (process.env.NODE_ENV !== 'production') {
    if (getDateSectionConfigFromFormatToken(utils, currentFormat).dateSectionName === 'weekDay') {
      throw new Error("changeSectionValueFormat doesn't support week day formats");
    }
  }
  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);
};
export var isFourDigitYearFormat = function isFourDigitYearFormat(utils, format) {
  return utils.formatByString(utils.date(), format).length === 4;
};
export var doesSectionHaveTrailingZeros = function doesSectionHaveTrailingZeros(utils, contentType, dateSectionName, format) {
  if (contentType !== 'digit') {
    return false;
  }
  if (dateSectionName === 'weekDay') {
    return utils.formatByString(utils.startOfWeek(utils.date()), format).length > 1;
  }

  // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.
  if (dateSectionName === 'year') {
    if (isFourDigitYearFormat(utils, format)) {
      var formatted0001 = utils.formatByString(utils.setYear(utils.date(), 1), format);
      return formatted0001 === '0001';
    }
    var formatted2001 = utils.formatByString(utils.setYear(utils.date(), 2001), format);
    return formatted2001 === '01';
  }
  return changeSectionValueFormat(utils, '1', format, format).length > 1;
};
var getEscapedPartsFromFormat = function getEscapedPartsFromFormat(utils, format) {
  var escapedParts = [];
  var _utils$escapedCharact = utils.escapedCharacters,
    startChar = _utils$escapedCharact.start,
    endChar = _utils$escapedCharact.end;
  var regExp = new RegExp("(\\".concat(startChar, "[^\\").concat(endChar, "]*\\").concat(endChar, ")+"), 'g');
  var match = null;
  // eslint-disable-next-line no-cond-assign
  while (match = regExp.exec(format)) {
    escapedParts.push({
      start: match.index,
      end: regExp.lastIndex - 1
    });
  }
  return escapedParts;
};
export var splitFormatIntoSections = function splitFormatIntoSections(utils, localeText, format, date) {
  var startSeparator = '';
  var sections = [];
  var commitToken = function commitToken(token) {
    if (token === '') {
      return null;
    }
    var expandedToken = utils.expandFormat(token);
    if (expandedToken !== token) {
      return expandedToken;
    }
    var sectionConfig = getDateSectionConfigFromFormatToken(utils, token);
    var sectionValue = date == null ? '' : utils.formatByString(date, token);
    var hasTrailingZeroes = doesSectionHaveTrailingZeros(utils, sectionConfig.contentType, sectionConfig.dateSectionName, token);
    sections.push(_extends({}, sectionConfig, {
      formatValue: token,
      value: sectionValue,
      placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),
      hasTrailingZeroes: hasTrailingZeroes,
      startSeparator: sections.length === 0 ? startSeparator : '',
      endSeparator: '',
      edited: false
    }));
    return null;
  };
  var splitFormat = function splitFormat(token) {
    var escapedParts = getEscapedPartsFromFormat(utils, token);
    var currentTokenValue = '';
    var _loop = function _loop(i) {
      var escapedPartOfCurrentChar = escapedParts.find(function (escapeIndex) {
        return escapeIndex.start <= i && escapeIndex.end >= i;
      });
      var char = token[i];
      var isEscapedChar = escapedPartOfCurrentChar != null;
      if (!isEscapedChar && char.match(/([A-Za-z]+)/)) {
        currentTokenValue += char;
      } else {
        // If we are on the opening or closing character of an escaped part of the format,
        // Then we ignore this character.
        var isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;
        if (!isEscapeBoundary) {
          var _expandedToken = commitToken(currentTokenValue);
          if (_expandedToken != null) {
            splitFormat(_expandedToken);
          }
          currentTokenValue = '';
          if (sections.length === 0) {
            startSeparator += char;
          } else {
            sections[sections.length - 1].endSeparator += char;
          }
        }
      }
    };
    for (var i = 0; i < token.length; i += 1) {
      _loop(i);
    }
    var expandedToken = commitToken(currentTokenValue);
    if (expandedToken != null) {
      splitFormat(expandedToken);
    }
  };
  splitFormat(format);
  var cleanSections = sections.map(function (section) {
    var cleanSeparator = function cleanSeparator(separator) {
      var cleanedSeparator = separator;
      if (cleanedSeparator !== null && cleanedSeparator.includes(' ')) {
        cleanedSeparator = "\u2069".concat(cleanedSeparator, "\u2066");
      }
      if (cleanedSeparator === '/') {
        cleanedSeparator = ' / ';
      }
      return cleanedSeparator;
    };
    section.startSeparator = cleanSeparator(section.startSeparator);
    section.endSeparator = cleanSeparator(section.endSeparator);
    return section;
  });
  return cleanSections;
};

/**
 * Some date libraries like `dayjs` don't support parsing from date with escaped characters.
 * To make sure that the parsing works, we are building a format and a date without any separator.
 */
export var getDateFromDateSections = function getDateFromDateSections(utils, sections) {
  // If we have both a day and a weekDay section,
  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.
  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.
  var shouldSkipWeekDays = sections.some(function (section) {
    return section.dateSectionName === 'day';
  });
  var sectionFormats = [];
  var sectionValues = [];
  for (var i = 0; i < sections.length; i += 1) {
    var section = sections[i];
    var shouldSkip = shouldSkipWeekDays && section.dateSectionName === 'weekDay';
    if (!shouldSkip) {
      sectionFormats.push(section.formatValue);
      sectionValues.push(getSectionVisibleValue(section, false));
    }
  }
  var formatWithoutSeparator = sectionFormats.join(' ');
  var dateWithoutSeparatorStr = sectionValues.join(' ');
  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
};
export var createDateStrForInputFromSections = function createDateStrForInputFromSections(sections) {
  var formattedArray = sections.map(function (section) {
    return "".concat(section.startSeparator).concat(getSectionVisibleValue(section, true)).concat(section.endSeparator);
  });

  // \u2066: start left-to-right isolation
  // \u2067: start right-to-left isolation
  // \u2068: start first strong character isolation
  // \u2069: pop isolation
  // wrap into an isolated group such that separators can split the string in smaller ones by adding \u2069\u2068
  return "\u2066".concat(formattedArray.join(''), "\u2069");
};
export var getSectionsBoundaries = function getSectionsBoundaries(utils) {
  var today = utils.date();
  var endOfYear = utils.endOfYear(today);
  var maxDaysInMonth = utils.getMonthArray(today).reduce(function (acc, month) {
    var daysInMonth = utils.getDaysInMonth(month);
    return Math.max(acc, daysInMonth);
  }, 0);
  return {
    year: function year(_ref) {
      var format = _ref.format;
      return {
        minimum: 0,
        maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99
      };
    },
    month: function month() {
      return {
        minimum: 1,
        // Assumption: All years have the same amount of months
        maximum: utils.getMonth(endOfYear) + 1
      };
    },
    day: function day(_ref2) {
      var currentDate = _ref2.currentDate;
      return {
        minimum: 1,
        maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth
      };
    },
    weekDay: function weekDay(_ref3) {
      var format = _ref3.format,
        contentType = _ref3.contentType;
      if (contentType === 'digit') {
        var daysInWeek = getDaysInWeekStr(utils, format).map(Number);
        return {
          minimum: Math.min.apply(Math, _toConsumableArray(daysInWeek)),
          maximum: Math.max.apply(Math, _toConsumableArray(daysInWeek))
        };
      }
      return {
        minimum: 1,
        maximum: 7
      };
    },
    hours: function hours(_ref4) {
      var format = _ref4.format;
      var hoursInDay = utils.getHours(endOfYear);
      var hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== hoursInDay.toString();
      return {
        minimum: 0,
        // Assumption: All days have the same amount of hours
        maximum: hasMeridiem ? Number(utils.formatByString(utils.startOfDay(today), format)) : hoursInDay
      };
    },
    minutes: function minutes() {
      return {
        minimum: 0,
        // Assumption: All years have the same amount of minutes
        maximum: utils.getMinutes(endOfYear)
      };
    },
    seconds: function seconds() {
      return {
        minimum: 0,
        // Assumption: All years have the same amount of seconds
        maximum: utils.getSeconds(endOfYear)
      };
    },
    meridiem: function meridiem() {
      return {
        minimum: 0,
        maximum: 0
      };
    }
  };
};

/**
 * @template TDate
 * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.*
 * @param {TDate} date The date on which the meridiem must be applied.
 * @param {string} sectionValue The new value of the meridiem section.
 * @returns {TDate} The date with the new meridiem.
 */
export var applyMeridiemChange = function applyMeridiemChange(utils, date, sectionValue) {
  var isAM = sectionValue.toLowerCase() === 'am';
  var hours = utils.getHours(date);
  if (isAM && hours >= 12) {
    return utils.addHours(date, -12);
  }
  if (!isAM && hours < 12) {
    return utils.addHours(date, 12);
  }
  return date;
};

/**
 * @template TDate
 * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.*
 * @param {TDate} date The date on which the week day must be applied.
 * @param {string} sectionFormat The format of the week day section.
 * @param {string} sectionValue The new value of the week day section.
 * @returns {TDate} The date with the new week day.
 */
export var applyWeekDayChange = function applyWeekDayChange(utils, date, sectionFormat, sectionValue) {
  var formattedDaysInWeek = getDaysInWeekStr(utils, sectionFormat);
  var dayInWeekStrOfActiveDate = utils.formatByString(date, sectionFormat);
  var dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
  var dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(sectionValue);
  var diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
  return utils.addDays(date, diff);
};
export var getDateSectionGetterAndSetter = function getDateSectionGetterAndSetter(utils, dateSectionName) {
  var adapterMethods = {
    seconds: {
      getter: utils.getSeconds,
      setter: utils.setSeconds
    },
    minutes: {
      getter: utils.getMinutes,
      setter: utils.setMinutes
    },
    hours: {
      getter: utils.getHours,
      setter: utils.setHours
    },
    day: {
      getter: utils.getDate,
      setter: utils.setDate
    },
    month: {
      getter: utils.getMonth,
      setter: utils.setMonth
    },
    year: {
      getter: utils.getYear,
      setter: utils.setYear
    }
  };
  return adapterMethods[dateSectionName];
};
export var cleanTrailingZeroInNumericSectionValue = function cleanTrailingZeroInNumericSectionValue(utils, format, value) {
  var size = utils.formatByString(utils.date(), format).length;
  var cleanValue = value;

  // We remove the trailing zeros
  cleanValue = Number(cleanValue).toString();

  // We add enough trailing zeros to fill the section
  while (cleanValue.length < size) {
    cleanValue = "0".concat(cleanValue);
  }
  return cleanValue;
};
var warnedOnceInvalidSection = false;
export var validateSections = function validateSections(sections, valueType) {
  var supportedSections = [];
  if (['date', 'date-time'].includes(valueType)) {
    supportedSections.push('weekDay', 'day', 'month', 'year');
  }
  if (['time', 'date-time'].includes(valueType)) {
    supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');
  }
  if (process.env.NODE_ENV !== 'production') {
    if (!warnedOnceInvalidSection) {
      var invalidSection = sections.find(function (section) {
        return !supportedSections.includes(section.dateSectionName);
      });
      if (invalidSection) {
        console.warn("MUI: The field component you are using is not compatible with the \"".concat(invalidSection.dateSectionName, " date section."), "The supported date sections are [\"".concat(supportedSections.join('", "'), "\"]`."));
        warnedOnceInvalidSection = true;
      }
    }
  }
};
export var mergeDateIntoReferenceDate = function mergeDateIntoReferenceDate(utils, date, sections, referenceDate, shouldLimitToEditedSections) {
  var mergedDate = referenceDate;
  sections.forEach(function (section) {
    if (!shouldLimitToEditedSections || section.edited) {
      if (section.dateSectionName === 'meridiem') {
        mergedDate = applyMeridiemChange(utils, mergedDate, utils.getHours(date) < 12 ? 'AM' : 'PM');
      } else if (section.dateSectionName === 'weekDay') {
        mergedDate = applyWeekDayChange(utils, mergedDate, section.formatValue, section.value);
      } else {
        var _getDateSectionGetter = getDateSectionGetterAndSetter(utils, section.dateSectionName),
          getter = _getDateSectionGetter.getter,
          setter = _getDateSectionGetter.setter;
        mergedDate = setter(mergedDate, getter(date));
      }
    }
  });
  return mergedDate;
};
export var isAndroid = function isAndroid() {
  return navigator.userAgent.toLowerCase().indexOf('android') > -1;
};
export var clampDaySection = function clampDaySection(utils, sections, sectionsValueBoundaries) {
  // We try to generate a valid date representing the start of the month of the invalid date typed by the user.
  var sectionsForStartOfMonth = sections.map(function (section) {
    if (section.dateSectionName !== 'day') {
      return section;
    }
    var dayBoundaries = sectionsValueBoundaries.day({
      currentDate: null,
      format: section.formatValue,
      contentType: section.contentType
    });
    return _extends({}, section, {
      value: section.hasTrailingZeroes ? cleanTrailingZeroInNumericSectionValue(utils, section.formatValue, dayBoundaries.minimum.toString()) : dayBoundaries.minimum.toString()
    });
  });
  var startOfMonth = getDateFromDateSections(utils, sectionsForStartOfMonth);

  // Even the start of the month is invalid, we probably have other invalid sections, the clamping failed.
  if (startOfMonth == null || !utils.isValid(startOfMonth)) {
    return null;
  }

  // The only invalid section was the day of the month, we replace its value with the maximum boundary for the correct month.
  return sections.map(function (section) {
    if (section.dateSectionName !== 'day') {
      return section;
    }
    var dayBoundaries = sectionsValueBoundaries.day({
      currentDate: startOfMonth,
      format: section.formatValue,
      contentType: section.contentType
    });
    if (Number(section.value) <= dayBoundaries.maximum) {
      return section;
    }
    return _extends({}, section, {
      value: dayBoundaries.maximum.toString()
    });
  });
};
export var getSectionOrder = function getSectionOrder(sections, isRTL) {
  var neighbors = {};
  if (!isRTL) {
    sections.forEach(function (_, index) {
      var leftIndex = index === 0 ? null : index - 1;
      var rightIndex = index === sections.length - 1 ? null : index + 1;
      neighbors[index] = {
        leftIndex: leftIndex,
        rightIndex: rightIndex
      };
    });
    return {
      neighbors: neighbors,
      startIndex: 0,
      endIndex: sections.length - 1
    };
  }
  var rtl2ltr = {};
  var ltr2rtl = {};
  var groupedSectionsStart = 0;
  var groupedSectionsEnd = 0;
  var RTLIndex = sections.length - 1;
  while (RTLIndex >= 0) {
    groupedSectionsEnd = sections.findIndex(
    // eslint-disable-next-line @typescript-eslint/no-loop-func
    function (section, index) {
      var _section$endSeparator;
      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' '));
    });
    if (groupedSectionsEnd === -1) {
      groupedSectionsEnd = sections.length - 1;
    }
    for (var i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {
      ltr2rtl[i] = RTLIndex;
      rtl2ltr[RTLIndex] = i;
      RTLIndex -= 1;
    }
    groupedSectionsStart = groupedSectionsEnd + 1;
  }
  sections.forEach(function (_, index) {
    var rtlIndex = ltr2rtl[index];
    var leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
    var rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
    neighbors[index] = {
      leftIndex: leftIndex,
      rightIndex: rightIndex
    };
  });
  return {
    neighbors: neighbors,
    startIndex: rtl2ltr[0],
    endIndex: rtl2ltr[sections.length - 1]
  };
};