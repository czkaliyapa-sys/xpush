import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import useEventCallback from '@mui/utils/useEventCallback';
import { useUtils } from '../useUtils';
import { applyMeridiemChange, applyWeekDayChange, changeSectionValueFormat, cleanTrailingZeroInNumericSectionValue, doesSectionHaveTrailingZeros, getDateSectionConfigFromFormatToken, getDateSectionGetterAndSetter, getDaysInWeekStr, isFourDigitYearFormat } from './useField.utils';
const QUERY_LIFE_DURATION_MS = 5000;
const isQueryResponseWithoutValue = response => response.saveQuery != null;

/**
 * Update the active section value when the user pressed a key that is not a navigation key (arrow key for example).
 * This hook has two main editing behaviors
 *
 * 1. The numeric editing when the user presses a digit
 * 2. The letter editing when the user presses another key
 */
export const useFieldCharacterEditing = ({
  sections,
  updateSectionValue
}) => {
  const utils = useUtils();
  const [query, setQuery] = React.useState(null);
  const resetQuery = useEventCallback(() => setQuery(null));
  React.useEffect(() => {
    var _sections$query$secti;
    if (query != null && ((_sections$query$secti = sections[query.sectionIndex]) == null ? void 0 : _sections$query$secti.dateSectionName) !== query.dateSectionName) {
      resetQuery();
    }
  }, [sections, query, resetQuery]);
  React.useEffect(() => {
    if (query != null) {
      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);
      return () => {
        window.clearTimeout(timeout);
      };
    }
    return () => {};
  }, [query, resetQuery]);
  const applyQuery = ({
    keyPressed,
    sectionIndex
  }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
    const cleanKeyPressed = keyPressed.toLowerCase();
    const activeSection = sections[sectionIndex];

    // The current query targets the section being editing
    // We can try to concatenated value
    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;
      const queryResponse = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);
      if (!isQueryResponseWithoutValue(queryResponse)) {
        setQuery({
          sectionIndex,
          value: concatenatedQueryValue,
          dateSectionName: activeSection.dateSectionName
        });
        return queryResponse;
      }
    }
    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);
    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {
      resetQuery();
      return null;
    }
    setQuery({
      sectionIndex,
      value: cleanKeyPressed,
      dateSectionName: activeSection.dateSectionName
    });
    if (isQueryResponseWithoutValue(queryResponse)) {
      return null;
    }
    return queryResponse;
  };
  const applyLetterEditing = params => {
    const findMatchingOptions = (format, options, queryValue) => {
      const matchingValues = options.filter(option => option.toLowerCase().startsWith(queryValue));
      if (matchingValues.length === 0) {
        return {
          saveQuery: false
        };
      }
      return {
        sectionValue: matchingValues[0],
        shouldGoToNextSection: matchingValues.length === 1
      };
    };
    const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, getOptions, fallbackFormat, formatFallbackValue) => {
      if (activeSection.contentType === 'letter') {
        return findMatchingOptions(activeSection.formatValue, getOptions(activeSection.formatValue), queryValue);
      }

      // When editing a digit-format month / weekDay and the user presses a letter,
      // We can support the letter editing by using the letter-format month / weekDay and re-formatting the result.
      // We just have to make sure that the default month / weekDay format is a letter format,
      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils, fallbackFormat).contentType === 'letter') {
        const fallbackOptions = getOptions(fallbackFormat);
        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);
        if (isQueryResponseWithoutValue(response)) {
          return {
            saveQuery: false
          };
        }
        return _extends({}, response, {
          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)
        });
      }
      return {
        saveQuery: false
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      switch (activeSection.dateSectionName) {
        case 'month':
          {
            const getOptions = format => utils.getMonthArray(utils.date()).map(month => utils.formatByString(month, format));
            const formatFallbackValue = fallbackValue => changeSectionValueFormat(utils, fallbackValue, utils.formats.month, activeSection.formatValue);
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, getOptions, utils.formats.month, formatFallbackValue);
          }
        case 'weekDay':
          {
            const getOptions = format => getDaysInWeekStr(utils, format);
            const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, getOptions, utils.formats.weekday, formatFallbackValue);
          }
        case 'meridiem':
          {
            const getOptions = format => {
              const now = utils.date();
              return [utils.endOfDay(now), utils.startOfDay(now)].map(date => utils.formatByString(date, format));
            };
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, getOptions);
          }
        default:
          {
            return {
              saveQuery: false
            };
          }
      }
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery);
  };
  const applyNumericEditing = (params, sectionsValueBoundaries, activeDate) => {
    const getNewSectionValue = (queryValue, dateSectionName, format, hasTrailingZeroes, contentType) => {
      const queryValueNumber = Number(`${queryValue}`);
      const sectionBoundaries = sectionsValueBoundaries[dateSectionName]({
        currentDate: activeDate,
        format,
        contentType
      });
      if (queryValueNumber > sectionBoundaries.maximum) {
        return {
          saveQuery: false
        };
      }

      // If the user types `0` on a month section,
      // It is below the minimum, but we want to store the `0` in the query,
      // So that when he pressed `1`, it will store `01` and move to the next section.
      if (queryValueNumber < sectionBoundaries.minimum) {
        return {
          saveQuery: true
        };
      }
      const shouldGoToNextSection = Number(`${queryValue}0`) > sectionBoundaries.maximum || queryValue.length === sectionBoundaries.maximum.toString().length;

      // queryValue without trailing `0` (`01` => `1`)
      let newSectionValue = queryValueNumber.toString();
      if (hasTrailingZeroes) {
        newSectionValue = cleanTrailingZeroInNumericSectionValue(utils, format, newSectionValue);
      }
      return {
        sectionValue: newSectionValue,
        shouldGoToNextSection
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      if (activeSection.contentType === 'digit') {
        return getNewSectionValue(queryValue, activeSection.dateSectionName, activeSection.formatValue, activeSection.hasTrailingZeroes, activeSection.contentType);
      }

      // When editing a letter-format month and the user presses a digit,
      // We can support the numeric editing by using the digit-format month and re-formatting the result.
      if (activeSection.dateSectionName === 'month') {
        const response = getNewSectionValue(queryValue, activeSection.dateSectionName, 'MM', doesSectionHaveTrailingZeros(utils, 'digit', 'month', 'MM'), 'digit');
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = changeSectionValueFormat(utils, response.sectionValue, 'MM', activeSection.formatValue);
        return _extends({}, response, {
          sectionValue: formattedValue
        });
      }

      // When editing a letter-format weekDay and the user presses a digit,
      // We can support the numeric editing by returning the nth day in the week day array.
      if (activeSection.dateSectionName === 'weekDay') {
        const response = getNewSectionValue(queryValue, activeSection.dateSectionName, activeSection.formatValue, activeSection.hasTrailingZeroes, activeSection.contentType);
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = getDaysInWeekStr(utils, activeSection.formatValue)[Number(response.sectionValue) - 1];
        return _extends({}, response, {
          sectionValue: formattedValue
        });
      }
      return {
        saveQuery: false
      };
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery, queryValue => !Number.isNaN(Number(queryValue)));
  };
  const applyCharacterEditing = useEventCallback(params => {
    const activeSection = sections[params.sectionIndex];
    const isNumericEditing = !Number.isNaN(Number(params.keyPressed));
    const getNewSectionValue = isNumericEditing ? applyNumericEditing : applyLetterEditing;
    updateSectionValue({
      activeSection,
      setSectionValueOnDate: (activeDate, sectionsValueBoundaries) => {
        const response = getNewSectionValue(params, sectionsValueBoundaries, activeDate);
        if (response == null) {
          return null;
        }
        if (activeSection.dateSectionName === 'meridiem') {
          const newDate = applyMeridiemChange(utils, activeDate, response.sectionValue);
          return {
            date: newDate,
            shouldGoToNextSection: true
          };
        }
        if (activeSection.dateSectionName === 'weekDay') {
          const newDate = applyWeekDayChange(utils, activeDate, activeSection.formatValue, response.sectionValue);
          return {
            date: newDate,
            shouldGoToNextSection: response.shouldGoToNextSection
          };
        }
        const {
          getter,
          setter
        } = getDateSectionGetterAndSetter(utils, activeSection.dateSectionName);
        let newSectionValue;
        // We can't parse the day on the current date, otherwise we might try to parse `31` on a 30-days month.
        // So we take for granted that for days, the digit rendered is always 1-indexed, just like the digit stored in the date.
        if (activeSection.contentType === 'digit' && activeSection.dateSectionName === 'day') {
          newSectionValue = Number(response.sectionValue);
        }
        // Day.js (and maybe other adapters) do not support correctly the parsing of standalone years.
        // To get the proper value
        // - if the format is a 4-digit year, we just use the section value.
        // - if the format is a 2-digit year, we add a trailing zero if needed and then parse the date.
        else if (activeSection.contentType === 'digit' && activeSection.dateSectionName === 'year') {
          if (isFourDigitYearFormat(utils, activeSection.formatValue)) {
            newSectionValue = Number(response.sectionValue);
          } else {
            const cleanValue = response.sectionValue.length === 1 ? `0${response.sectionValue}` : response.sectionValue;
            const sectionDate = utils.parse(cleanValue, activeSection.formatValue);
            newSectionValue = getter(sectionDate);
          }
        } else {
          // The month is stored as 0-indexed in the date (0 = January, 1 = February, ...).
          // But it is often rendered as 1-indexed in the input (1 = January, 2 = February, ...).
          // This parsing makes sure that we store the digit according to the date index and not the input index.
          const sectionDate = utils.parse(response.sectionValue, activeSection.formatValue);
          newSectionValue = getter(sectionDate);
        }
        const newDate = setter(activeDate, newSectionValue);
        return {
          date: newDate,
          shouldGoToNextSection: response.shouldGoToNextSection
        };
      },
      setSectionValueOnSections: sectionsValueBoundaries => getNewSectionValue(params, sectionsValueBoundaries, null)
    });
  });
  return {
    applyCharacterEditing,
    resetCharacterQuery: resetQuery
  };
};